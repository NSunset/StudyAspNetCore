1、泛型在编译之后，参数会生成占位符`，有几个类型参数有显示`几
2、最终会根据调用生成不同的普通方法
3、泛型不是语法糖，是编译器+clr合作支持的
4、一个方法（类、）满足不同类型的需求，性能足够高，延迟执行，根据具体的调用生成不同的实例在执行
5、泛型缓存，缓存就是一个暂存区，还是存到内存中。
6、泛型类，根据不同的类型生成不同的副本。类型不同每个类都不同
7、泛型约束：针对类型不安全，在传入参数的时候加上约束。
	基类约束：where T:类
	接口约束：where T:接口
	无参数构造函数约束：where T:new() 传入的参数必须有无参数构造函数
	值类型约束：where T:struct 传入的参数必须是值类型
	引用类型约束：where T:class 传入的参数必须是引用类型

8、协变、逆变
	协变 修饰符out：T只能做返回值，不能做参数
		实现泛型父类可以声明泛型子类的实例，并且约束T不能作为方法参数，来避免类型安全问题
			类型安全问题：父类声明时T为父类，实现类的T为子类，当声明对象调用方法时，传入参数一旦为父类，则实					现类报错，因为实现类参数T为子类，无法传入父类

	逆变 修饰符in：T只能做参数，不能做返回值
		实现泛型子类可以声明泛型父类，并且约束T不能作为方法返回值，来避免类型安全问题
			类型安全问题：子类声明时T为子类，实现类的T为父类，当声明对象调用方法时，返回参数一旦为子类，					则实现类报错，因为实现类的返回参数T为父类，即可以返回父类，而声明对象返回的是子类。违反继承原则，报错
	

